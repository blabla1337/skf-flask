use me for a header
Filename injection Path traversal
XSS injection
Command injection
Cross site request forgery
XXE injections
X Path injections
XML injection
XSLT injections
External DTD parsing
LDAP injection
SSI injections
File upload injections
Version management
Verbose error messaging
Debug enabeling
Robots.txt
Accessible non parsed dynamic scripts
Include anti caching headers
Include anti clickjacking headers
Include X XSS
Include X Content Type Options header
Include Strict Transport Security header
Sensitive information stored in cookies
Client side state management
Too verbose authentication
Brute force password guessing
Denial of service by locking out accounts
Predictable password and or token generation
Unauthorized credential changes
Double decoding of headers parameters
Resource identifier injection
Dynamic scripting injection
Regular expression injection
Automated spamming via feedback scripts
Session cookies without the Secure attribute
Session cookies without the HttpOnly attribute
External session hijacking
Insecure transmission of session cookies
Unproven cryptographic algorithms
Client side authentication
Identifier based authorization
Principle of complete mediation
Prepared statements and query parameterization
Are all passwords hashed, salted and stretched
Sensitive information transmitted by unencrypted methods
Session information is not stored server side
The crossdomain xml should only contains trusted domains
Session ids should be generated with sufficient entropy
User generated session ids should be rejected by the server
The logout functionality should revoke the complete session
The login functionality should always generate a new session id
Does The application enforce the use of secure passwords
Session IDs do not timeout (idl)
Directory listing
Unnecessary features enabled or installed
Avoid the use of default and predictable acounts.
Security settings in your development frameworks
Insecure datastorage
Authentication based on the knowledge of a secret URL
Open forward and Open redirects
Incorrect or missing charset
Extraneous files in document root
Username enumeration
HTTP header injection
GET POST requests
Insecure internal communication
Sensitive information stored alongside the source code
The possible risks to the application must be documented
Possible attackers of the application must be documented
Audit logs
User credentials in audit logs
Intrusion detecting and reporting
Authentication at a central location
IP adresses in internal HTTP headers
Authentication enforced by the web sever
The audit log must include a priority system
Servers must not be trusted without explicit authentication
Ensure overall security
Re authentication
No shared knowledge for secret questions
Disallow the use of old passwords
Absolute session time out
Logout structuring
Verify that the sensitive information is never disclosed
Session Domain cookies
Access control failure
Input rejection
Input validation
Single input validation controls
Logging validation failures
Logging implemented on the serverside
Logging guidelines
Log viewing software code injection
CA certificates
All connections should be TLS
Log TLS connection failures
Content type headers
Malicious intent
Sandboxing
Repudiation attack
Server side validation
Privilege escalation
Enforce sequential step order
Step up or adaptive authentication
Cross origin resource sharing
Prevent password pre filling
All authentication controls must fail securely
Forget password functions
Aggregate access control protection
Canonicalized user input
Approved random number generator
Validated cryptographic modules
Policy for managing cryptographic keys
HTTPS and weakly or unencrypted links
Error handling on trusted devices
Single application level logging
Aggregate user requests
Principle of least privilege
TLS implementation must operate in an approved mode of operation
Character encoding
HTTP request methods
Verbose version information
HTTP headers added by a frontend
Session management control
Available log analysis tools
Distinguish log
Sanitise sensitive data rapidly from memory
Logging is performed before executing the transaction
Verify integrity using checksums
Deny access from remote resources or systems
Certificate paths revocation information
HTML Caching and client side caching
Cryptographic modules should operate in their approved mode according to their published security policies
Sending data parameters to untrusted devices
Proces high value business logic flows in a trusted environment
Data from untrusted sources
User restriction for sensitive data
Runtime environment
Automatic parameter binding
Cryptographic function implementation
Cryptographic modules must fail securely
Access to any master secret must be protected from unauthorized access
Enforce policys for sensitive data processing
Access control pattern
Password forget pattern
Sessions pattern
Submit forms pattern
SQL injection Column truncation
User registration pattern
Cross subdomain cookie attack
HTML injections
RFD and file download injections
Identify all application components
Identify external dependencies
High level architecture should be defined
Threat modeling
Differential analysis attack
Client side input validation
Positive validation model
TLS certificate public key pinning
HSTS preload
Forward secrecy ciphers
OCSP stapling
STRIDE
File inclusion attack
Access management
XML schema (XSD)
Limiting user input size
Parsing data  exchange formats
Content security policy headers
Safe javascript jquery methods
WYSIWYG editors
Parsing JSON with Javascript
Account lockout
XML attacks
Centralized security controls
Data controller display layer separation
Proven authentication mechanisms
Administrative interfaces must not be accessible to untrusted parties
Concurrent session handling
Auto escaping technology
Client side storage
Log rotation and seperation
HTTP strict transport security
API responses security headers
Do not support untrusted client side technologies
Signed message payloads WS security
Hardware key vault
SOAP basic profile
Strong CRYPTO through CA hierachy
Build and deploy in a secure fashion
Signed application components
Build proccess security hardening
Sanitize unstructured data
Zero keys and secrets before destroying them
Keys and passwords should be replaceable
Enforce random numbers are created with proper entropy at runtime
Segregated components
PII protection
Verify application is not vulnerable for known security issues
Disable autocomplete for all the input fields in forms
All time sources should be synchronized
Generate strong crypto tokens with at least 120 bit of effective entropy
Enforce sensitive information to be stored encrypted on device
Encrypt sensitive information different depending on context
Secrets should be secure random generated
Protection against different exfiltration techniques
Principle of least privilege
Protecting device memory
Enforce anti debugging techniques
Protect sensitive activities intents or content providers
Mitigate memory dumping attacks
Protect agains exported activities or content providers
Block common password and weak passphrases
Application assets hosted on secure location
CSRF on REST
File IO commands
File upload anti virus check
File upload outside document root
Authentication integrety checks
Unauthorized and unauthenticated access security logs
Commonly chosen weak passwords and passphrases
Two factor authentication
Logging access control decisions
High value transactions
Verify that structured data is strongly typed and validated
Logging guidelines to access sensitive information
Log injection
Validate the integrity of all security relevant configurations
Trusted repositories
Sandboxing malicious code
Client side constraints
Context sensitive authorization
All access controls must fail securely
Password leakage
TLS implementation
Screen scraping data harvest
Communication between components (low privileges)
TLS settings are in line with current leading practice
Data retention policy
Authenticated data cleared from client storage
All error handling logic must fail securely
Sensitive information in code or online repositories
Identify all components
Display concurrent and active sessions
Password change leads to destroying concurrent sessions
HSTS preload
Integrity check and authorised modification
Unauthorised access and modification
Identify and use only require functions if using components
Centralized the mechanisms for protecting resources and the access
Third party components
Policy for processing sensitive data
Server side request forgery
ASVS
MASVS
PCI DSS
Tabnabbing
Server side template injection
Insecure direct object references
Type checking and length checking
SMTP IMAP injection
Insecure object deserialization
Software security development lifecycle
Functional security constraints
Attribute based authorization
Key management and key lifecycle by NIST
Key vault
Secrets shared with the client
Data protection levels
Source control systems in place
Continuous security testing
Security test automation
Referrer policy header
Insecure application defaults
Infrastructure as code
GraphQL security
JSON validation schema
Serve files whitelist.
User supplied scriptable or expression template language content
Replay attacks
Same site attribute
Host prefix
Race conditions
Sub domain take over
No password rotation policy
User notification on critical state changing operations
Stateless session tokens
GUID v4
Exception handling
Back up data
Static code analysis
TLS
Code signing
Secure random generators
not available item
Sensitive Information Exposure in URL
Sensitive Information Exposure in client Side Storage
Session Token Generation After Login
Secure Generation of Session Tokens
Ensure Session Validation in Credential Service Provider and Relying Parties.md
Permit Password Change
Provide Password Strength Checker
Verify Breached Passwords
Offline Attacks on Passwords
Password Hash Salt Length
PBKDF2 Iteration Count
Bcrypt Work Factor
OOB Unencrypted
Secure OOB Channel
OOB PIN Expiry
OOB Key Used Once
Unsafe password reset
Presence of Knowledge
Current Password Exposure
Implement Two Factor Authentication for Password Recovery
Identity Spoofing
Multifcator Authentication Exposure
Authentication Factor Notification
MinimumPasswordLength
PermitLongPasswords
Permit Spaces In Passwords
Permit Unicode Characters In Passwords
Change And Validate Current Password
List of compromised passwords
Password Strength Indicator
No Character type limitation
No Credential Rotation Requirements
Logout session expiration
Reauthentication valid sessions
Change password session expiration
Samesite cookie attribute
Weak revocability of physical authenticators
Lack of Bruteforce Protection
Improper Two Factor Authenticators design
Impersonation resistance not sufficent
