## Description:

The product implements a cryptographic algorithm using a non-standard or unproven cryptographic primitive.

Cryptographic algorithms (or Cryptographic systems) depend on cryptographic primitives as their basic building blocks. As a result, cryptographic primitives are designed to do one very specific task in a precisely defined and highly reliable fashion. For example, one can declare that a specific crypto primitive (like an encryption routine) can only be broken after trying out N different inputs (the larger the value of N, the stronger the crypto). If a vulnerability is found that leads to breaking this primitive in significantly less than N attempts, then the specific cryptographic primitive is considered broken, and the entirety of the cryptographic algorithm (or the cryptographic system) is now considered insecure. Thus, even breaking a seemingly small cryptographic primitive is sufficient to render the whole system vulnerable. Cryptographic primitives are products of extensive reviews from cryptographers, industry, and government entities looking for any possible flaws. However, over time even well-known cryptographic primitives lose their compliance status with emergence of novel attacks that might either defeat the algorithm or reduce its robustness significantly. If ad-hoc cryptographic primitives are implemented, it is almost certain that such implementation will be vulnerable to attacks resulting in the exposure of sensitive information and/or other consequences.

## Mitigation:


PHASE:Architecture and Design:
Follow these good cryptography practices: Do not create your own crypto algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm can be compromised when attackers find out how it works, then it is especially weak. Do not use outdated/not-compliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. Do not use LFSR as a substitute for proper Random Number Generator IPs. Do not use checksum as a substitute for proper Hashes. Design the hardware at the IP level so that one cryptographic algorithm can be replaced with another in the next generation. Use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. Do not store keys in areas accessible to untrusted agents. Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant. Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and might be more likely to avoid errors that can occur during implementation of cryptographic algorithms. When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.:EFFECTIVENESS:High

